//实验3
// 八皇后问题
// 目的要求：用C++语言求解八皇后问题，加强应用C++程序设计语言对问题进行分解和求解的能力。
// 实验内容：
// 八皇后问题，是一个古老而著名的问题，是回溯算法的典型例题。
// 该问题是十九世纪著名的数学家高斯1850年提出：在8X8格的国际象棋上摆放八个皇后，
// 使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法？
// 在本实验中至少实现两种摆法，并输出所实现的摆法。
#include<iostream>
#include<cmath>//包含abs() 取绝对值 
#include <iomanip> //setw(int n)设置宽度
using namespace std;

//全局 要在函数里更新数值
int hh[8]; //定义八个皇后坐标，[]里的代表是第几(0~7)个，也是第几行，等号后面就是第几列
int count = 0; //计算有多少种放法

void Show()
{
    count++; //加一种
    int n = 0; //不放(no)
    int y = 1; //放(yes)
    cout << "------------------------------------------------" << endl;
    for(int w_1=0;w_1<8;w_1++)
    {
        for(int w_2=0;w_2<8;w_2++)
        {
            if(hh[w_1]==w_2)
            {
                cout << setw(5) << y;
            }
            else
            {
                cout << setw(5) << n;
            }
        }
        cout << "\n"; //输出下一行
    }
    cout << "------------------------------------------------" << endl;
}
void Set(int i)//放置第i行的皇后，也是第i个皇后
{
    if(i==8)//如果全放完了，输出这一种
    {
        Show();//show函数执行完之后，回到上一个
    }
    else 
    {
        for(int t_1=0;t_1<8;t_1++)
        {
            hh[i] = t_1; //这里我们将0~7设置为坐标范围,t_1代表的i行t_1列
            int t_2 = 0; //第0个已经放好的皇后
            while(t_2<i) //与前面的皇后比较，检查在这一列是否合适
            {
                if((hh[t_2]!=hh[i])&&(abs(t_2-i)!=(abs(hh[t_2]-hh[i]))))
                {
                    t_2++;
                    if(t_2==i) //代表第i个和前面没有冲突，继续放下一个
                    {
                        Set(i+1); 
                    }
                }
                else //有冲突马上换下一列，再比较
                {
                    break;
                }
            }
        }
    }
}
int main()
{
    for(int j=0;j<8;j++)//第0个皇后在哪一列
    {
        hh[0]=j;
        Set(1);
    }
    cout << "Sum = " << count << endl; 
    return 0;
        
}
